#include  "stm32f10x.h"
#include  "./led/bsp_led.h"
#include  "./uart/bsp_uart.h"
#include  "./spi/bsp_spi.h"
#include  "bsp_cc1101.h"
#include "bsp_iwdg.h"
#define	length			8

extern void delay(uint32_t count);

/***********************************************************************
*************************copyright(c)***********************************
***********************************************************************/

/***********************************************************************
	*	Author	:	xuzhi Liu
	*	Date	:	2017.11.12
	*	Version	:	1.0.0
	*	Brief	:	1.测试SPI通讯   SPI2
	*				2.硬件连接: *	*12  ---> SPI2-- CS 	*	
	*							*							*
	*							*	PB13  ---> SPI2--S	*	*	*	*	*	*	
	*							*	PBCLK 	*
	*							*							*
	*							*	PB14  ---> SPI2--MISO	*
	*							*							*
	*							*	PB15  ---> SPI2--MOSI	*
	*							*	*	*	*	*	*	*	*
	*							 	
	*							IOCFG2(GDO2) 任意连接一个LED灯作为测试
	*
	*							添加硬件连接 GDIO0 --> PA2	针对接收端,发送端不用
	*
	*				3.SPI通讯说明：写数据：①.先发送写命令(一般是地址),②.再发送写数据
	*							   读数据：①.先发送读命令(一般是地址),②.再发送读数据命令
	*				
	*
	*		History
	*			1.	Author	:	xuzhi Liu
	*				Date	:	2017.11.12
	*				Mod		:	初次配置SPI通讯相关初始化API
	*							配置为master模式，软件控制片选
	*
	*
	*			2.	Author	:	xuzhi Liu
	*				Date	:	2018.11.12
	*				Mod		:	添加bsp_cc1101文件，初次测试SPI与CC1101通信,通过SPI通信配置CC1101的GDO0引脚高低电平
	*
	*
	*			3.	Author	:	xuzhi Liu
	*				Date	:	2018.11.16
	*				Mod		:	1.添加bsp_systick.c和bsp_systick.h文件,添加两个延时函数,精准延时.
	*							2.经过测试发现写寄存器,如果只写命令,可以只发命令
	*							  如果是读数据,第一次发完读地址后,必须再发一次读的指令,单字节读取,则发送指令0x80,
	*							  连续读取,则发送指令0xC0,在bsp_cc1101.h中有宏定义。
	*							3.修改Write_bye函数为Test_Write_Read_byte,仅仅用于测试,添加发送数据函数Write_Data函数
	*							  其实,Write_Date函数就是以前的Write_byte函数。
	*							4.为便于使用连续(burst)读写模式,在SPI_Send函数中加入1us延时,后续其他地方就不再添加延时
	*
	*
	*			4.	Author	:	xuzhi Liu
	*				Date	:	2018.11.17
	*				Mod		:	配置CC1101寄存器,添加发送函数
	*
	*
	*			5.	Author	:	xuzhi Liu
	*				Date	:	2018.11.19
	*				Mod		:	添加GDIO引脚配置,作为发送或接收判定置位,在cc1101寄存器初始化代码配置
	*							为0x06(发送/接收到同步字时置位).添加代码放在bsp_led.c和bsp_led.h文件中
	*							
	*
	*
	*			6.	Author	:	xuzhi Liu
	*				Date	:	2018.11.20
	*				Mod		:	1.测试连续收发函数
	*							2.测试发送接收包函数
	*							3.已知bug：1)清空接收缓存区RX FIFO仍能读书数据
	*									   2)接收到的数据和发送的数据之间错位一个单位
	*									   3)停止发送后,仍能接收数据
	*
	*
	*			7.	Author	:	xuzhi Liu
	*				Date	:	2018.11.22
	*				Mod		:	1.继续测试收发函数
	*							2.添加CRC校验函数,文件放在bsp_cc1101.c文件中
	*							bug 3)已解决 原因:数据接收完成后,会自动转入IDLE状态,手动拉进IDLE状态导致一直有数据
	*							bug 1)已解决 原因:接收缓存区RX FIFO其实没有数据,打印看到的数据不是缓存区的数据
	*
	*			8.	Author	:	xuzhi Liu
	*				Date	:	2018.11.26
	*				Mod		:	解决bug②,原因：在接收过程和和读取接收缓存区数据之间未加延时
	*
	*
	*
	*			9.	Author	:	xuzhi Liu
	*				Date	:	2018.11.27
	*				Mod		:	测试发现新bug：第一次正确接收到数据并读取后,再次发送读取数据函数
	*							ReadRxFIFO(pBuff,len)还能读到除数据长度不正确的字节数外，其余数据正确
	*							产生此bug的原因:单次发送,接收出现此bug
	*
	*
	*			10.	Author	:	xuzhi Liu
	*				Date	:	2018.11.28
	*				Mod		:	在接收数据包函数里添加两个判定语句,接解决通过延时来判定的不准确性bug
	*							即用两个判定语句代替延时函数。11.27号bug已解决:加入两个判定语句,条件不满足不会进入读取接收缓存区数据
	*							添加硬件连接: GDIO0与MCU的PA2相连,针对接收函数
	*							发现bug:接收端会出现一定概率的卡死现象,原因不明
	*
	*
	*			11.	Author	:	xuzhi Liu
	*				Date	:	2018.12.05
	*				Mod		:	找到卡死bug原因,接收完成，数据读取完后应当置位,但没有置位，导致卡死在while里
	*							解决方法:当读取完数据后,再次发送冲洗接收缓存区指令,强制使GDIO0置位
	*	
	*
	*			12.	Author	:	xuzhi Liu
	*				Date	:	2018.12.19
	*				Mod		:   为解决担心程序跑飞的问题,添加独立看门狗定时器,选择3s内如果没有喂狗则系统复位,并且添加LED作为指示
	*							现象说明: 复位后板载LED灯亮1s,然后熄灭,如果在3s之内没有喂狗,则LED会再次闪烁,乳沟有喂狗则不会闪烁
	*							目前遇到的新问题: 因为系统的复位会导致本应该输出高电平(或低电平),因为复位导致默认值,所以在实际应
	*							用中建议使用边沿触发的设备,如磁保持继电器等。
	*
	*
	*			13. Author	:	xuzhi Liu
	*				Date	:	2019.04.02
	*				Mod		:	经过实际测试发现一段时间未接收数据后，再次接收数据无法接收,查看CC1101数据手册发现，有定时器，一段
	*							时间后终止了RX,
	*							解决方法：在未接收数据的死循环里强制使其进入RX模式(具体效果有待测试)
	*									  后续测试发现有一定的几率出现跑飞,具体原因不明
	*									  跑飞测试是在野火STM32F103RCT6 MINI开发板上发现,但是在STM32F103C8T6最小板上测试并没有出现跑飞
	*
	*
	*			14. Author	:	xuzhi Liu
	*				Date	:	2019.04.26
	*				Mod		:	添加唯一地址识别,即发送端和接收端必须配套,否则无法接受到数据
	*							说明: 经过实际测试发现,开启地址识别(地址滤波,无法实现CRC滤波),此CRC滤波是接收数据包滤波的CRC,其中可以自己做个CRC校验
	*								  关于在发送数据时的数据长度,如果开启了地址识别,则发送的数据长度为字节长度＋数据长度
	*								  针对发送端代码
	*
*******************************************************************************************************/


int main(void)	
{
	uint8_t Rx_Buffer[8]={0x00};   //接收数组的长度最好为sizeof[Tx_Buffer]+3,Tx_Buffer为发送端的发送数据数组
	uint8_t i = 0;
//	uint8_t Crc_result = 0; 
	
	
	
	
	
	
#if 1
/**********************************************************************************		
	* lixing code begin	 
	*	数据整合
**********************************************************************************/	

	uint16_t Tem_Hum_Convert[3] = {0x00,0x00,0x00};
	float Tem_Hum[2];

		
/**********************************************************************************		
	* lixing code end
**********************************************************************************/	
#endif
	
	GPIO_Config();
	Led_GPIO_Config();
//	LED1(1);
//  Delay_ms(1000);	
//	IWDG_Start();	//开启看门狗,开始计时
//	LED1(0);
	UART_Init();
	SPI_Config();
	
/******************************************************************** 
 *说明:复位后GDIO0会亮灯,而GDIO2会闪烁,其中GDIO2高电平表示电源和晶振还未稳定
 *     解释为何上电两个灯会闪烁的原因
********************************************************************/
	
	CC1101_Reset();					//复位后GDIO0会亮灯,此时的GDIO0并不是RX FIFO接收置位
	CC1101_Init();

	while(1)
	{
/*******************************************************************
		*	Author	:	xuzhi Liu
		*	Date	:	2018.11.20
*******************************************************************/

		//接收数据
		CC1101_RFDataPack_Rceive(Rx_Buffer,sizeof(Rx_Buffer));
/**********************************************************************************		
	* lixing code begin	 
	*	数据整合
**********************************************************************************/	
#if 1

	Tem_Hum_Convert[0] = Rx_Buffer[5];
    Tem_Hum_Convert[0] <<= 8;
    Tem_Hum_Convert[0] |= Rx_Buffer[4];
		
	Tem_Hum[0] = (float)(Tem_Hum_Convert[0])/100;
		
	Tem_Hum_Convert[1] = Rx_Buffer[7];
    Tem_Hum_Convert[1] <<= 8;
    Tem_Hum_Convert[1] |= Rx_Buffer[6];
	Tem_Hum[1] = (float)(Tem_Hum_Convert[1])/100;
		
	printf("\n*******************打印接收到的原始数据**************\n");
	for(i=0; i< sizeof(Rx_Buffer);i++)
	{
		printf("\n %d    Rx_Buffer data is: %x\r\n",i,Rx_Buffer[i]);
	}	
		
	printf("\n*******************打印接收到的整合数据**************\n");
	
	printf("\nSHT21采集到的温度是: %.2f℃\r\n",Tem_Hum[0]);
	printf("\nSHT21采集到的湿度是: %.2f%%\r\n",Tem_Hum[1]);
	
#endif
		
/**********************************************************************************		
	* lixing code end
**********************************************************************************/	
		
#if 0
		//打印接收到的数据
		printf("\n*******************打印接收到的数据**************\n");
		for(i=0; i< sizeof(Rx_Buffer);i++)
		{
			printf("\nRx_Buffer data is: %x\r\n",Rx_Buffer[i]);
		}

		//对接收到的数据进行CRC校验(不包括长度和地址)
		Crc_result = Crc_Calcu(Rx_Buffer,(sizeof(Rx_Buffer)));
		
		//如果接收到数据的校验值等于0x4C,并且地址是0xAA(0x4C是不包括长度字节和地址字节),说明接收到的数据没问题,闪灯
//		if(((((Rx_Buffer[sizeof(Rx_Buffer)-1]) & 0x80 ) >> 7 )== CRC_OK) && (Crc_result == 0x47))
		if((Crc_result== 0x4C) && (Rx_Buffer[1] == CC1101_UNIQUE_ADDR))
		{
			//闪灯
			LED1(1);
			LED3(1);
			Delay_ms(100);							//延时0.5s
			LED1(0);
			LED3(0);
		}
		
		//如果接收到数据的校验值等于0x49,并且地址是0xAA(0x4C是不包括长度字节和地址字节),说明接收到的数据没问题,开灯
		if((Crc_result== 0x49) && (Rx_Buffer[1] == CC1101_UNIQUE_ADDR))
		{
			//亮灯
			LED1(1);
			LED3(1);
		}
		
		//如果接收到数据的校验值等于0x47,并且地址是0xAA(0x4C是不包括长度字节和地址字节),说明接收到的数据没问题,关灯
		if((Crc_result== 0x47) && (Rx_Buffer[1] == CC1101_UNIQUE_ADDR))
		{
			//灭灯
			LED1(0);
			LED3(0);
		}
		//清空接收区的数据
		for(i=0;i<sizeof(Rx_Buffer);i++)
		{
			Rx_Buffer[i] = 0x00;
		}
				
		/* 需要执行的功能性代码完成后开始喂狗 */
		//说明:如果在3s内还没有完成上面的功能性代码,则可能代码出现跑飞的现象,由于得不到喂狗,就会产生系统复位
//		IWDG_Feed();  //喂狗不让其产生复位信号

#endif 
	}
}
	
